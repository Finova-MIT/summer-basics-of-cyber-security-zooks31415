1) PIE TIME
Flag: picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_80c3b8b7}
Solution: Note down memory address of main, and the memory address of win, using the concept that the difference always remains same, You take the difference of the two
addresses and store it. Then using nc, port connect to picoCTF and run which executes the binary. a PIE or position independent file is loaded at a new random location 
on the memory every time it is executed. So the program executes and displays the address of main for the particular execution, using the stored difference , we can get
the address of win andgive it as an input to get the flag.

2) PIE TIME 2 
Flag: picoCTF{p13_5h0u1dn'7_134k_1ef23143}
Solution: This challenge involves a format string vulnerability that can be easily discovered upon inspection of the c file. Since the program does not reveal the address
of main upon execution, we have to leak it by exploiting the format string vulnerability. To do that we first find out the position on the stack that our buffer is
pushed. It turns out to be the 8th position in this particular case. After that, we find the return address of the call_functions function. Using the concept that the
offset between the memory addresses of (a part of )main (here the return address of the call functions function) and win functions always remain the same, We note down 
the offset. Then we use the nc command and deploy our payload as %x %X %X %X %X %X %X %X.... we find the address at the 8th position and offset it by the stored value
calculated previously to get the address of the win function . Then we input the result(address of the win function) to get the flag.

3) format String 0
Flag: picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_63191ce6}
Solution: Looking at the c code, I figured out that I had to trigger the segfault handler to print out the flag, I typed in  Gr%114d_Cheese first to enter the serve_bob()
function and then typed  Cla%sic_Che%s%steak which crashed the program and hence revealed the flag

4) format string 1
Flag: 
